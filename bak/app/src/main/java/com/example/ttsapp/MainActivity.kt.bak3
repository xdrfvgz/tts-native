package com.example.ttsapp

import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioTrack
import android.net.Uri
import android.os.Bundle
import android.view.View
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.example.ttsapp.databinding.ActivityMainBinding
import ai.onnxruntime.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class MainActivity : AppCompatActivity() {
    private var _binding: ActivityMainBinding? = null
    private val binding get() = _binding!!
    private var ortSession: OrtSession? = null
    private var isProcessing = false
    private var audioTrack: AudioTrack? = null

    companion object {
        private const val SAMPLE_RATE = 22050
    }

    private val getContent = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let { loadExternalModel(it) }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        try {
            super.onCreate(savedInstanceState)
            _binding = ActivityMainBinding.inflate(layoutInflater)
            setContentView(binding.root)
            
            // Initial UI Setup
            binding.synthesizeButton.isEnabled = false
            binding.progressBar.visibility = View.GONE
            binding.modelStatus.text = "Kein Modell geladen"
            
            setupListeners()
            
            // Load model in background
            lifecycleScope.launch {
                tryLoadingBuiltinModel()
            }
        } catch (e: Exception) {
            // Notfall-Feedback falls UI crashed
            Toast.makeText(this, "Startup Error: ${e.message}", Toast.LENGTH_LONG).show()
        }
    }

    private suspend fun tryLoadingBuiltinModel() {
        withContext(Dispatchers.IO) {
            try {
                val modelBytes = assets.open("models/tts_model.onnx").use { it.readBytes() }
                loadModelFromBytes(modelBytes)

                withContext(Dispatchers.Main) {
                    binding.modelStatus?.text = "Eingebautes Modell aktiv"
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    binding.modelStatus?.text = "Kein eingebautes Modell"
                }
            }
        }
    }

    private fun loadExternalModel(uri: Uri) {
        _binding?.let { binding ->
            binding.synthesizeButton.isEnabled = false
            binding.loadModelButton.isEnabled = false
            binding.progressBar.visibility = View.VISIBLE

            lifecycleScope.launch(Dispatchers.IO) {
                try {
                    val modelBytes = contentResolver?.openInputStream(uri)?.use { it.readBytes() }
                        ?: throw Exception("Konnte Modelldatei nicht lesen")

                    loadModelFromBytes(modelBytes)

                    withContext(Dispatchers.Main) {
                        binding.modelStatus.text = "Externes Modell aktiv"
                    }
                } catch (e: Exception) {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@MainActivity,
                            "Modelladung fehlgeschlagen: ${e.message}",
                            Toast.LENGTH_LONG
                        ).show()
                    }
                } finally {
                    withContext(Dispatchers.Main) {
                        binding.loadModelButton.isEnabled = true
                        binding.progressBar.visibility = View.GONE
                    }
                }
            }
        }
    }

    private suspend fun loadModelFromBytes(modelBytes: ByteArray) {
        try {
            val env = OrtEnvironment.getEnvironment()
            ortSession?.close() // Clean up old session
            ortSession = env.createSession(modelBytes)

            withContext(Dispatchers.Main) {
                _binding?.synthesizeButton?.isEnabled = true
                Toast.makeText(this@MainActivity, "Model erfolgreich geladen", Toast.LENGTH_SHORT).show()
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                Toast.makeText(this@MainActivity, "Model-Error: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun setupListeners() {
        _binding?.let { binding ->
            binding.loadModelButton.setOnClickListener {
                try {
                    getContent.launch("application/octet-stream")
                } catch (e: Exception) {
                    Toast.makeText(this, "File Picker Error: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }

            binding.synthesizeButton.setOnClickListener {
                if (!isProcessing) {
                    val text = binding.inputText.text?.toString() ?: ""
                    if (text.isNotEmpty()) {
                        synthesizeText(text)
                    } else {
                        Toast.makeText(this, "Bitte Text eingeben", Toast.LENGTH_SHORT).show()
                    }
                }
            }
        }
    }

    private fun synthesizeText(text: String) {
        _binding?.let { binding ->
            isProcessing = true
            binding.progressBar.visibility = View.VISIBLE
            binding.synthesizeButton.isEnabled = false

            lifecycleScope.launch(Dispatchers.IO) {
                try {
                    val session = ortSession ?: throw Exception("Model nicht geladen")

                    val env = OrtEnvironment.getEnvironment()
                    val input = OnnxTensor.createTensor(env, arrayOf(text))

                    val output = session.run(mapOf("text" to input))
                    val audioData = output[0].value as Array<*>

                    playAudio(audioData)

                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@MainActivity,
                            "Audio generiert (${audioData.size} samples)",
                            Toast.LENGTH_SHORT
                        ).show()
                    }

                } catch (e: Exception) {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@MainActivity,
                            "Fehler: ${e.message}",
                            Toast.LENGTH_LONG
                        ).show()
                    }
                } finally {
                    withContext(Dispatchers.Main) {
                        binding.progressBar.visibility = View.GONE
                        binding.synthesizeButton.isEnabled = true
                        isProcessing = false
                    }
                }
            }
        }
    }

    private fun playAudio(audioData: Array<*>) {
        try {
            audioTrack?.release()

            val minBufferSize = AudioTrack.getMinBufferSize(
                SAMPLE_RATE,
                AudioFormat.CHANNEL_OUT_MONO,
                AudioFormat.ENCODING_PCM_FLOAT
            )

            audioTrack = AudioTrack.Builder()
                .setAudioAttributes(AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_MEDIA)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build())
                .setAudioFormat(AudioFormat.Builder()
                    .setEncoding(AudioFormat.ENCODING_PCM_FLOAT)
                    .setSampleRate(SAMPLE_RATE)
                    .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                    .build())
                .setBufferSizeInBytes(minBufferSize)
                .build()

            val floatArray = audioData.map { (it as? Number)?.toFloat() ?: 0f }.toFloatArray()
            audioTrack?.play()
            audioTrack?.write(floatArray, 0, floatArray.size, AudioTrack.WRITE_BLOCKING)
        } catch (e: Exception) {
            lifecycleScope.launch(Dispatchers.Main) {
                Toast.makeText(
                    this@MainActivity,
                    "Audio-Wiedergabe fehlgeschlagen: ${e.message}",
                    Toast.LENGTH_LONG
                ).show()
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            audioTrack?.release()
            ortSession?.close()
            _binding = null
        } catch (e: Exception) {
            // Ignore cleanup errors
        }
    }
}
